#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# Copyright (c) 2015 Rasmus Sorensen, rasmusscholer@gmail.com <scholer.github.io>

##    This program is free software: you can redistribute it and/or modify
##    it under the terms of the GNU General Public License as published by
##    the Free Software Foundation, either version 3 of the License, or
##    (at your option) any later version.
##
##    This program is distributed in the hope that it will be useful,
##    but WITHOUT ANY WARRANTY; without even the implied warranty of
##    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##    GNU General Public License for more details.
##
##    You should have received a copy of the GNU General Public License

# pylint: disable=C0103,W0142,C0111


"""
This file is used to assert the efficiency of using AWSfile rather than
building a bytearray, converting it and passing it to requests.

The tests generally show that using AWSfile:
1) decreases memory consumption by 33 %
2) reduces the total time it takes to produce a Request by no less than 50 % !!

In other words, pretty significant performance improvements.

Run this file with:
>>> python memory_consumption_tests.py [MOCK_OPEN] [print_memory] [timeit]
Where:
 *  MOCK_OPEN   will use in-memory generated bytes rather than read file from disk.
                (if you do not use MOCK_OPEN, you have to change "testfn"
                below to be a local file on your disk...)
 *  print_memory will print memory usage during execution.
 *  timeit      will run timings benchmarks.
                (print_memory should not be used together with timeit.)

"""

testfn = "C:/Users/scholer/Downloads/gtk+-bundle_3.6.4-20131201_win64.zip"


import sys
import os
from io import BytesIO
import psutil
import requests
from urllib.parse import urljoin
import timeit

open_builtin = open

sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

#print(sys.path)
#print(os.listdir(sys.path[1]))
from pyzotero import awsfile


HTTPBIN = os.environ.get('HTTPBIN_URL', 'http://httpbin.org/')
# Issue #1483: Make sure the URL always has a trailing slash
HTTPBIN = HTTPBIN.rstrip('/') + '/'
def httpbin(*suffix):
    """Returns url for HTTPBIN resource."""
    return urljoin(HTTPBIN, '/'.join(suffix))



def make_bytes(MB=100):
    # We need 2**(20*MB) bytes
    # range(256) gives us 2**8 bytes.
    # We need 2**(20*MB-8) of these:
    #return b''.join(i for x in range(MB*2**(20-8)) for i in range(256))
    #return bytes(bytearray(i for x in range(int(MB*2**(20-8))) for i in range(256)))
    # Edit: This is actually terribly slow...
    # Or just (and not care about the values):
    return bytes(int(MB*2**20))


# In many cases, the disk IO may be just as fast as creating the bytes:
# (the file is probably cached)
MOCK_OPEN = False
if MOCK_OPEN or 'mock_open' in sys.argv:
    TEST_BYTES = make_bytes(31)
    test_bytesio = BytesIO(TEST_BYTES)

from contextlib import contextmanager

@contextmanager
def fake_open(filepath, *args, **kwargs):
    print("Using fake_open on %s, %s, %s" % (filepath, args, kwargs))
    #test_bytesio.seek(0)
    try:
        yield test_bytesio
    finally:
        print("fake_open completed, resetting...")
        test_bytesio.seek(0)


def fake_open_fun(filepath, *args, **kwargs):
    print("Using fake_open on %s, %s, %s" % (filepath, args, kwargs))
    #test_bytesio.seek(0)
    return test_bytesio
    # No way to ensure that something is called after returning...
    # That's why a context manager uses yield.

class FakeOpen(object):
    """ A fake file open `With` context manager. """
    def __init__(self, filepath, *args, **kwargs):
        print("Created FakeOpen on %s, %s, %s" % (filepath, args, kwargs))
        self._fp = test_bytesio
    def __enter__(self):
        """
        Return the object that is used as the "as <variable>" in:
            with FakeOpen(...) as fp:
                ...
        """
        return self._fp
    def __exit__(self, exc_type, exc_value, traceback):
        #print("Resetting test_bytesio...")
        self._fp.seek(0)
    def read(self, size=None):
        return self._fp.read(size)
    def tell(self):
        return self._fp.tell()


def get_test_bytes():
    return open(testfn, 'rb').read()


def memory_usage_psutil():
    """ return the memory usage in MB """
    process = psutil.Process(os.getpid())
    mem = process.get_memory_info()[0] / float(2 ** 20)
    return mem



def test_bytearray():
    mb = [0]
    mb.append(int(memory_usage_psutil()))
    print("Bytearray:")
    print("Start memory:", memory_usage_psutil())
    bts = get_test_bytes()
    print("Read file to %s object: %s MB" % (type(bts), int(len(bts)/2**20)))

    mb.append(int(memory_usage_psutil()))
    print("After making bytes object from file:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    #byio = BytesIO(bts)
    mb.append(int(memory_usage_psutil()))
    print("After making BytesIO from bytes:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    #ba = bytearray(bts)
    mb.append(int(memory_usage_psutil()))
    print("After making bytearray:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    #baio = BytesIO(ba)
    mb.append(int(memory_usage_psutil()))
    print("After making BytesIO from bytearray:", mb[-1], " - delta: ", mb[-1]-mb[-2])

#from six import string_types


    #def bytegen(self, ):
    #    yield self._head
    #    yield self._fp.read()

def test_AWSfile(print_memory=False):
    head = b' '*1024
    tail = b' '*2048
    # monkeypatch builtin open:
    #open = FakeOpen # fake_open. Edit: Doesn't actually happen here...
    if MOCK_OPEN or 'mock_open' in sys.argv:
        awsfile.open = FakeOpen
        awsfile.getsize = lambda x: len(TEST_BYTES)
    if print_memory:
        mb = [0]
        mb.append(int(memory_usage_psutil()))
        print("\ntest_AWSfile, starting point:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    file_data = awsfile.AWSfile(head, testfn, tail, delayed=False)
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After creating AWSfile object:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    data = {'a': 'a string'}
    files = {'b': file_data}
    r = requests.Request('POST', httpbin('post'), data=data, files=files)
    p = r.prepare()
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After preparing request:", mb[-1], " - delta: ", mb[-1]-mb[-2])
        print("Total memory for operation:", mb[-1]-mb[1])

    assert 'multipart/form-data' in p.headers['Content-Type']

def test_original(print_memory=False):
    head = b' '*1024
    tail = b' '*2048
    # monkeypatch builtin open:
    if MOCK_OPEN or 'mock_open' in sys.argv:
        open = FakeOpen # pylint: disable=W0622
    else:
        open = open_builtin
    if print_memory:
        mb = [0]
        mb.append(int(memory_usage_psutil()))
        print("\ntest_original, starting point:", mb[-1], " - delta: ", mb[-1]-mb[-2])
    upload_file = bytearray(head)
    #filebytes = open(testfn, 'rb').read()  # Wait, if you use this, you have to seek manually!
    #filebytes = fake_open_fun(testfn, 'rb').read()
    #test_bytesio.seek(0)    # Remember to seek if you are not using a context manager
    with open(testfn, 'rb') as fp:
        filebytes = fp.read()
    # Try even the fastest version:
    #filebytes = TEST_BYTES  # Even this is much slower...
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After reading filebytes from file:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    upload_file.extend(filebytes)
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After appending filebytes to bytearray:", mb[-1], " - delta: ", mb[-1]-mb[-2])
    upload_file.extend(tail)

    upload_file = file_data = bytes(upload_file) # If you overwrite, this doesn't show up in memory stats.
    #file_data = bytes(upload_file) # If you overwrite, this doesn't show up in memory stats.
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After converting bytearray to bytes:", mb[-1], " - delta: ", mb[-1]-mb[-2])

    data = {'a': 'a string'}
    #files = {'b': upload_file}
    files = {'b': file_data}
    r = requests.Request('POST', httpbin('post'), data=data, files=files)
    p = r.prepare()
    if print_memory:
        mb.append(int(memory_usage_psutil()))
        print("After preparing request:", mb[-1], " - delta: ", mb[-1]-mb[-2])
        print("Total memory for operation:", mb[-1]-mb[1])

    assert 'multipart/form-data' in p.headers['Content-Type']


def test_buffer():
    pass



def test():
    #test_bytearray()
    #import profile

    #profile.run('test_AWSfile()')
    #timeit.timeit('test_AWSfile()')
    nruns = 1000
    print_memory = 'print_memory' in sys.argv
    #t = timeit.timeit('test_buffer(%s)' % print_memory, setup="from __main__ import test_buffer", number=nruns)
    #print("test_buffer: %s runs in %s secs = %s msec/run" % (nruns, t, t*1000/nruns))

    if 'timeit' in sys.argv:
        nruns = 10
        t = timeit.timeit('test_original(%s)' % print_memory, setup="from __main__ import test_original", number=nruns)
        print("test_original: %s runs in %s secs = %s msec/run" % (nruns, t, t*1000/nruns))

        #nruns = 5
        t = timeit.timeit('test_AWSfile(%s)' % print_memory, setup="from __main__ import test_AWSfile", number=nruns)
        print("test_AWSfile: %s runs in %s secs = %s msec/run" % (nruns, t, t*1000/nruns))
    else:
        test_AWSfile(print_memory)
        test_original(print_memory)


if __name__ == '__main__':
    test()
